synchronized锁升级过程
1）偏向锁 在 JDK1.8 中，其实默认是轻量级锁，但如果设定了 -XX:BiasedLockingStartupDelay = 0 ，那在对一个 Object 做 syncronized 的时候，会立即上一把偏向锁。
当处于偏向锁状态时， markwork 会记录当前线程 ID 。
2）升级到轻量级锁 当下一个线程参与到偏向锁竞争时，会先判断 markword 中保存的线程 ID 是否与这个线程 ID 相等，如果不相等，会立即撤销偏向锁，升级为轻量级锁。
每个线程在自己的线程栈中生成一个 LockRecord ( LR )，然后每个线程通过 CAS (自旋)的操作将锁对象头中的 markwork 设置为指向自己的 LR 的指针，哪个线程设置成功，就意味着获得锁。
3）升级到重量级锁 如果锁竞争加剧(如线程自旋次数或者自旋的线程数超过某阈值， JDK1.6 之后，由 JVM 自己控制该规则)，就会升级为重量级锁。
此时就会向操作系统申请资源，线程挂起，进入到操作系统内核态的等待队列中，等待操作系统调度，然后映射回用户态。在重量级锁中，由于需要做内核态到用户态的转换，而这个过程中需要消耗较多时间，也就是"重"的原因之一。


Java里的线程有哪些状态？
1）初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
2）运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
3）阻塞(BLOCKED)：表示线程阻塞于锁。
4）等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5）超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。
6）终止(TERMINATED)：表示该线程已经执行完毕。


在 Java 中有以下 3 种方法可以终止正在运行的线程：
1）使用退出标志，使线程正常退出，也就是当 run() 方法完成后线程中止。
2）使用 stop() 方法强行终止线程，但是不推荐使用这个方法，该方法已被弃用。
    调用 stop() 方法会立刻停止 run() 方法中剩余的全部工作，包括在 catch 或 finally 语句中的，并抛出ThreadDeath异常(通常情况下此异常不需要显示的捕获)，
    因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。
    调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题。
3）使用 interrupt 方法中断线程。线程中断并不会立即终止线程，而是通知目标线程，有人希望你终止。至于目标线程收到通知后会如何处理，则完全由目标线程自行决定。


并发编程三要素？
1）原子性 原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操作打断，要么就全部都不执行。
2）可见性 可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立即看到修改的结果。
3）有序性 有序性，即程序的执行顺序按照代码的先后顺序来执行。


CyclicBarrier和CountDownLatch的区别
1）CountDownLatch简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并且调用countDown()方法发出通知后，当前线程才可以继续执行。
2）cyclicBarrier是所有线程都进行等待，直到所有线程都准备好进入await()方法之后，所有线程同时开始执行！
3）CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。
4）CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。如果被中断返回true，否则返回false。


sleep() 方法和 wait() 方法的区别和共同点?
1）相同点： 两者都可以暂停线程的执行，都会让线程进入等待状态。
2）不同点： sleep()方法没有释放锁，而 wait()方法释放了锁。 sleep()方法属于Thread类的静态方法，作用于当前线程；而wait()方法是Object类的实例方法，作用于对象本身。
执行sleep()方法后，可以通过超时或者调用interrupt()方法唤醒休眠中的线程；执行wait()方法后，通过调用notify()或notifyAll()方法唤醒等待线程。

避免死锁
1）我们应该避免一个线程获取多个锁。
2）其次如果一个线程真的需要多个锁，我们应该确保所有线程都以相同的顺序获取锁，来避免获取锁时的循环依赖问题。
3）我们也可以使用带有超时功能的锁，像Lock接口中的tryLock方法，来确保一个线程如果获取不到锁不会一直阻塞。

什么是活锁
1）在活锁中，两个或多个线程彼此间一直在转移状态，而不像我们上个例子中互相等待。结果就是所有线程都不能执行它们各自的任务。
2）一个比较好的活锁例子就是消息队列。当发生异常的时候，消息消费者回滚事务并把消息放到队列头中，然后相同的消息又从队列头中被读到，又会造成异常并再次放入到队列头中。
如此循坏往复，消费者永远读不到队列中其他的消息。

避免活锁
1）避免活锁我们得观察一下活锁发生的条件并根据情况提出方案，比如：
如果我们有两个线程在重复的获取锁和释放锁导致了活锁，我们可以修改下代码让两个线程以一个随机的时间间隔来获取锁，这样线程就有机会获取到它们需要的锁了。
2）另一个方式来解决我们前面提到的消息队列的问题就是把失败的消息放到单独的的队列中去进一步处理而不是再次放入原队列中。
（这个在实际开发中还真遇到过，开发的时候漏掉了一个情况，导致循环消费多条错误消息，队列消息大量积压，要不是队列报警，险些造成线上bug，
所以生产环境的队列消费最好还是设置个失败次数加上死信队列，不然出问题可真受不了。）

线程的饥饿问题:
实际就是线程都去执行A任务,导致后续B任务没有线程执行,
解决方法, 一个线程负责A任务,一个线程负责B任务
https://www.cnblogs.com/heliusKing/p/12288226.html


线程池都有哪几种工作队列？
ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。
LinkedBlockingQueue：是一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。
SynchronousQueue：是一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。
PriorityBlockingQueue：一个具有优先级的无限阻塞队列。


Thread.sleep(0)的作用是什么？
由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，
可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。