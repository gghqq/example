https://www.hollischuang.com/archives/2374
java内存组成介绍：堆(Heap)和非堆(Non-heap)内存
一、JVM主要管理两种类型的内存：堆和非堆。
    堆就是Java代码可及的内存，是留给开发人员使用的；
    非堆就是JVM留给自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中。
二、JVM内存区域模型:
    1.方法区
    也称”永久代” 、“非堆”， 它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。
    运行时常量池：是方法区的一部分，其中的主要内容来自于JVM对Class的加载。
    Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。
    2.虚拟机栈
    每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。
    局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。
    局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。
    3.本地方法栈
    与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。
    4.程序计数器
    是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成
    5.堆
    也叫做java 堆、GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象)。
    其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，默认为操作系统物理内存的1/64但小于1G，-Xmx为JVM可申请的最大内存，默认为物理内存的1/4但小于1G，默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。
    由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象
    新生代： 程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。
    老年代： 用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。 老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。
三、直接内存
    1.直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。
四、Java堆内存的10个要点
    1.Java堆内存是操作系统分配给JVM的内存的一部分。
    2.当我们创建对象时，它们存储在Java堆内存中。
    3.为了便于垃圾回收，Java堆空间分成三个区域，分别叫作New Generation(新生代), Old Generation(老年代)或叫作Tenured Generation，还有Perm Space(元空间)。
    4.你可以通过用JVM的命令行选项 -Xms, -Xmx, -Xmn来调整Java堆空间的大小。不要忘了在大小后面加上”M”或者”G”来表示单位。举个例子，你可以用 -Xmx256m来设置堆内存最大的大小为256MB。
    5.你可以用JConsole或者 Runtime.maxMemory(), Runtime.totalMemory(), Runtime.freeMemory()来查看Java中堆内存的大小。
    6.你可以使用命令“jmap”来获得heap dump，用“jhat”来分析heap dump。
    7.Java堆空间不同于栈空间，栈空间是用来储存调用栈和局部变量的。
    8.Java垃圾回收器是用来将死掉的对象(不再使用的对象)所占用的内存回收回来，再释放到Java堆空间中。
    9.当你遇到java.lang.outOfMemoryError时，不要紧张，有时候仅仅增加堆空间就可以了，但如果经常出现的话，就要看看Java程序中是不是存在内存泄露了。
    10.请使用Profiler和Heap dump分析工具来查看Java堆空间，可以查看给每个对象分配了多少内存。
五、Java堆设置常用参数
    -Xms	堆内存初始大小
    -Xmx（MaxHeapSize）	堆内存最大允许大小，一般不要大于物理内存的80%
    -XX:NewSize（-Xns）	年轻代内存初始大小
    -XX:MaxNewSize（-Xmn）	年轻代内存最大允许大小，也可以缩写
    -XX:NewRatio  新生代和老年代的比值  值为4 表示 新生代:老年代=1:4，即年轻代占堆的1/5
    -XX:SurvivorRatio=8     年轻代中Eden区与Survivor区的容量比例值，默认为8 表示两个Survivor :eden=2:8，即一个Survivor占年轻代的1/10
    -XX:+HeapDumpOnOutOfMemoryError  内存溢出时，导出堆信息到文件
    -XX:+HeapDumpPath    堆Dump路径,-Xmx20m -Xms5m  -XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=d:/a.dump
    -XX:OnOutOfMemoryError  当发生OOM内存溢出时，执行一个脚本 -XX:OnOutOfMemoryError=D:/tools/jdk1.7_40/bin/printstack.bat %p   %p表示线程的id pid
    -XX:MaxTenuringThreshold=7	表示如果在幸存区移动多少次没有被垃圾回收，进入老年代

六.类加载过程
    1.加载
        通过一个类的全限定名来获取定义此类的二进制流
        将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
        在内存中生成一个该类的Class对象.作为该类的各种数据访问入口
        加载源:Class文件, 网络,计算机生成(动态代理),其他文件(Jsp). 数据库
    2.连接
        验证:确保Class文件的字节流符合虚拟机要求
           文件格式验证:验证字节流是否符合Class文件格式的规范(是否以魔数0xCAFEBABE开头,主次版本号是否在当前虚拟机处理范围等)
           元数据验证:这个类是否有父类(除了object,都应有),是否继承了不允许继承的类(final)等.
           字节码验证:数据流和控制流分析.保证跳转指令不会跳转到方法体以外的字节码指令上.等
           符号引用验证:符号引用通过字符串描述的全限定名是否能找到对应的类,指定类中存在是否符合方法的字段描述符及方法和字段等
                    如果所有代码都已被反复加载使用和验证过,在实施阶段可以通过-Xverify:none关闭大部分验证,缩短虚拟机类加载时间
        准备:为类变量分配内存并设置类变量初始值阶段.
            只对类变量分配初始值. 例如static int a = 123. 在此阶段a初始值为0.
            而Constant Value   例如static final int a = 123,则准备阶段初始值为123
        解析:虚拟机将常量池内的符号引用替换为直接引用的过程:
    3.初始化:执行类构造器<clinit>()方法的过程.
            虚拟机保证一个类的<clinit>()方法在多线程环境中被正确的枷锁和同步,如果多个线程去同时初始化一个类,则只有一个线程去执行这个类的<clinit>()方法,其他都要阻塞等待. 可以通过此方式创建线程安全的单例类

七.JVM类加载器
    1.启动类加载器.用来加载java核心类库.无法被java程序直接引用.负责加载JAVA_HOME/lib下面的核心类库或者-Xbootclasspath指定的jar包加载到内存中
    2.扩展类加载器.用来加载java扩展库.java虚拟机的实现会提供一个扩展库目录.负责将JAVA_HOME/lib/ext或者-Djava.ext.dir指定位置中的类库加载到内存中.开发者可以直接使用标准扩展类加载器
    3.系统类加载器.根据java应用的类路径来加载java类.通过ClassLoader.getSystemClassLoader()来获取它
    4.用户自定义类加载器,通过集成java.lang.ClassLoader类的方式实现


八.JAVA对象的布局 https://baijiahao.baidu.com/s?id=1678403904600805381&wfr=spider&for=pc
    总体分为三个:
    1.对象头.对象头由两个字(计算机术语)构成
        Mark Word :  图片对象头在64位计算机中的组成
            锁标志位(lock):区分锁状态,11代表等待GC回收的状态,10代表重量级锁,00代表轻量级锁,01是无锁态或者偏向锁
            biased_lock":是否偏向锁，由于正常锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。
            分代年龄:标识对象被GC的次数
            对象的hashCode:运行期间调用System.identityHashCode()来计算，延迟计算，并把结果赋值到这里。当对象加锁后，计算的结果31位不够表示，在偏向锁，轻量锁，重量锁，hashcode会被转移到Monitor中。
            偏向锁的线程ID:当某个线程持有对象的时候,这里被设置为该线程ID,后面操作就无须进行再次尝试获取锁的动作
            epoch偏向锁的标识:偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。
            ptr_to_lock_record:轻量级锁指向栈中锁记录的指针,当锁获取是无竞争的时，JVM使用原子操作而不是OS互斥。这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过CAS操作在对象的标题字中设置指向锁记录的指针。
            ptr_to_heavyweight_monitor:重量级锁状态下，指向对象监视器Monitor的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。

    2.实例数据
    3.对其填充