背景:一共130个项目左右  一年有12个月  平均每个项目有5年左右的数据 获取所有项目所有收费数据逐个计算
问题现象: 服务刚开始启动,数据库查询挺快,几分钟后速度特别慢, 通过arthas发现任务处于TIME_WAITING中.任务逐渐超时(1h).
解决过程: 通过jastack和arthas发现线程大多数处于TIME_WAITING的状态.
         排查代码
原因和疑惑: 通过代码排查发现,对项目进行循环时使用了并行流(parallelStream),并在流里面使用了线程池(核心数大小20),猜测是因为并行流里面同时执行任务数太多 130*12*5 同时还处理其他业务,
          导致线程上下文切换频繁,或者说来不及及时切换上下文, 导致项目执行失败.
          为什么设置核心线程数后,同时使用并行流会导致任务超时.    设置核心线程数后,同时使用并发流,线程数达到上限,程序是怎样运行的


 2.问题现象:   程序无法访问
   排解过程: 使用arthas发现老年代使用99%,年轻代使用99%,s0使用99%,频繁GC.   IO交互 running,任务处于TIME_WAITING
            使用jmap -histo 1984 | head 30 查看占用较大的对象
            jmap -dump:live,format=b,file=adsearch.dump 1984 导出dump文件 并下载到本地
            通过JProfiler 远程连接查看jvm运行情况   把dump改后缀.hprof 使用JProfiler分析 发现某个类实例比较多占用大小非常大. 在检查里面通过选择堆栈引用的对象可以看到某个实现类引用.
            选择该类,通过传入引用可以查看该类被谁引用, 大概在哪个位置
   结论: 使用并行流同时执行,猜测一些项目某几个月数据量大,导致执行时间久,并同时执行此处,创建大量对象. 导致老年代爆满. 通过JProfiler可以分析大概是哪个位置代码
   解决方案: 通过业务方式解决,把小区拆分几组执行,或单独执行某些大数据小区的某几个月




