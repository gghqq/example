在Java语言中，可作为GC Roots的对象包括下面几种：（京东）
 虚拟机栈中引用的对象（栈帧中的本地变量表）；
 方法区中类静态属性引用的对象；
 方法区中常量引用的对象；
 本地方法栈中JNI（Native方法）引用的对象。

一.垃圾回收判断对象是否存活的算法
1.1引用计数法
 * 堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。
 * 当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），
 * 但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。
 * 任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。
1.2可达性分析算法 @/垃圾回收/FinalizeEscapeGC
    基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），
    当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。
    真正宣告一个对象死亡，至少要经历两次标记过程,如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，
    筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，

2.Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。
强引用
    在程序代码中普遍存在的，类似 Object obj = new Object() 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
软引用
    用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。
弱引用
    也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。比如 threadlocal
虚引用
    也叫幽灵引用或幻影引用（名字真会取，很魔幻的样子），是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知。。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。
3.方法区存储内容是否需要回收的判断可就不一样咯。方法区主要回收的内容有：废弃常量和无用的类。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：
    该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
    加载该类的ClassLoader已经被回收；
    该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

二.垃圾回收算法
1.1标记清除(Mark-Sweep)
标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。
特点:高效,但容易产生内存碎片
1.2复制算法(Copying)
内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。
特点:原理简单,但是使用内存缩为原来一半.Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。
1.3标记整理(Mark-compact)
先进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动(完成标记之后，先不清理，先移动再清理回收对象!!!)，然后清理掉端边界以外的内存，并更新对应的指针。最后清理标记的对象
特点:在标记-清除算法的基础上，又进行了对象的移动，成本更高，但是却解决了内存碎片的问题。
1.4分代收集算法 Generational Collection
    大部分JVM的垃圾收集器采用的算法。将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代永久代（Permanet Generation）
新生代采用(copy)算法,因为新生代需要回收大部分对象,那复制的对象就少. 但是新生代是采用 Eden:server0:server1=8:1:1
    进行回收时，将Eden和S0中还存活的对象复制到另一块S1空间中，然后清空Eden和刚才使用过的S0空间。此时S0是空的,将s0区和s1区交换，即保持s1区为空.当Eden没有足够空间的时候就会 触发jvm发起一次Minor GC
    当s1区不足以存放 eden和s0的存活对象或一个对象的存活次数达到15次时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC(Major GC)，也就是新生代、老年代都进行回收。
老年代采用(Mark-compact) 算法
    当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。每次回收都只回收少量对象，
新生代和老年代的区别(阿里面试)
    新生代和老年代是针对于分代收集算法来定义的，新生代又分为Eden和Survivor两个区。加上老年代就这三个区。数据会首先分配到Eden区当中（特殊情况如果是大对象那么会直接放入到老年代（大对象是指需要大量连续内存空间的java对象）。）
    ，当Eden没有足够空间的时候就会触发jvm发起一次Minor GC。如果对象经过一次Minor GC还存活，并且又能被Survivor空间接受，那么将被移动到Survivor空 间当中。
    并将其年龄设为1，对象在Survivor每熬过一次Minor GC，年龄就加1，当年龄达到一定的程度（默认为15）时，就会被晋升到老年代 中了，当然晋升老年代的年龄是可以设置的。
    如果老年代满了就执行：Full GC 因为不经常执行，因此采用了 Mark-Compact算法清理

三.常见的垃圾收集器
Serial收集器（复制算法)
    新生代单线程收集器，标记和清理都是单线程，优点是简单高效。是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定。
Serial Old收集器(标记-整理算法)
    老年代单线程收集器，Serial收集器的老年代版本。
ParNew收集器(停止-复制算法)　
    新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。
Parallel Scavenge收集器(停止-复制算法)
    并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数。
Parallel Old收集器(停止-复制算法)
Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。
CMS(Concurrent Mark Sweep)收集器（标记-清理算法）
    高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择。
      (1)初始标记(Stop the World事件)	年老代里的对象被标记为可达的包括那些可能从年轻代可达的对象。此期间暂停时间相对minor gc的暂停时间是比较 短的
      (2)并发标记	当Java应用线程运行时，并发的遍历年老代对象图可达的对象。从标记的对象和根上可达到标记对象开始扫描。设值方法在并发的2、3、5阶段期间执行，在这些阶段(包括晋升的对象)被分配进CMS代所有对象都会立刻被标记为活跃对象。
      (3)重新标记(Stop the World事件)	寻找那些在并发标记阶段丢失的，在并发收集器完成之后跟踪对象之后由Java应用线程的更新的对象。
      (4)(并发清除)	收集在标记阶段被鉴定为不可达的对象。收集死亡对象会增加空闲列表的空间，方便之后的对象分配。聚合死亡对象可以会在此点发生。注意活跃对象是不会被移动。
      (5)(重新设置)	清理数据结构为下一次并发收集做准备
G1(Garbage First) 优先处理垃圾多的内存块.-----------------阿里面试!!!
    Java应用的内存使用观察得到的结论,90%的对象熬不过第一次垃圾回收，而老的对象(经历了好几次垃圾回收的对象)则有98%的概率会一直活下来.
    G1垃圾收集器把堆分割成连续相同大小的区域,每一个都是连续范围的虚拟内存.每个内存都会被标记Eden/old/Survivor/Humongous(巨型对象)中的一个.
    G1的另一个显著特点他能够让用户设置应用的暂停时间，G1回收的第4步，它是“选择一些内存块”，而不是整代内存来回收，这是G1跟其它GC非常不同的一点，其它GC每次回收都会回收整个Generation的内存(Eden, Old), 而回收内存所需的时间就取决于内存的大小，以及实际垃圾的多少，所以垃圾回收时间是不可控的；
    而G1每次并不会回收整代内存，到底回收多少内存就看用户配置的暂停时间，配置的时间短就少回收点，配置的时间长就多回收点，伸缩自如。 (阿里面试)
    当G1的eden块不够分配时会触发young GC,活跃对象会拷贝到survivor或者晋升old.当old占比达到触发标准时触发mixed gc,除了回收e,还会回收部分o.
    mixed gc过程: 第一步 初始标记(initial mark),主要标记GC root可达对象,整个过程STW(stop-the-world),
                 第二步 根区扫描,为那些将要到达老年代的引用扫描survivor区.
                 第二步和应用线程并发标记(concurrent mark).标记GC对象衍生出去的可达对象,并记录各块存活情况.
                 第三步最终标记(remark),整个过程STW.标记并发过程中遗漏的或者发生变化的对象
                 第四步垃圾清除过程(clean up).整个过程STW
    如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc.
    目标是多处理器机器、大内存机器。它高度符合垃圾收集暂停时间的目标，同时实现高吞吐量


